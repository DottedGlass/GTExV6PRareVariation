# ===================================================================================================================
# This is a main script for running RIVER for computing posterior probabilities with 10 cross-validation
#
# input:
#       1. genomic_features.txt: a [N x (P+2)] matrix with values of genomic features
#          N is the total number of instances (individual and gene pairs). 
#          P is the total number of genomic features.
#          First two columns consist of individual IDs and gene names.
#       2. Zscores.txt: a [N x (T+2)] matrix with Z-score values
#          N is the total number of instances (individual and gene pairs). 
#          T is the total number of tissues considered
#          First two columns consist of individual IDs and gene names.
#
# output:
#       1. RIVER.10CV.out.RData
#          Store all data used and generated by running this script
#
# ===================================================================================================================

#!/usr/bin/env Rscript

# Load required packages
rm(list = ls())
library(pROC)

# Master directory
dir = Sys.getenv('RAREVARDIR')

# Recall required functions
source('RIVER.R')

# =========== Load input data
G = read.table(paste(dir,"/data/genomic_features.txt",sep=""), sep='\t', header = TRUE, na.strings = "NaN") # genomic features
E = read.table(paste(dir,"/data/Zscores.txt",sep=""), sep='\t', header = TRUE, na.strings = "NaN") # z-scores



# =========== Main
# Compute |Median Z-scores|
E_vals = apply(E[,3:ncol(E)], 1, function(x) abs(median(x, na.rm=TRUE)));

# Find multi-tissue outliers
E_disc = as.numeric(E_vals >= 1.5);

# Standardize genomic features of training data
g_all = as.matrix(G[,3:ncol(G)])
mean_col_g = apply(g_all,2,mean)
sd_col_g = apply(g_all,2,sd)
g_all <- (g_all-matrix(rep(mean_col_g,dim(g_all)[1]),byrow=TRUE,nrow=dim(g_all)[1]))/
  matrix(rep(sd_col_g,dim(g_all)[1]),byrow=TRUE,nrow=dim(g_all)[1])

G[,3:ncol(G)] <- g_all

basic_data = cbind(E_disc, G);
pred_data = data.frame(matrix(NA,nrow(basic_data),2)) # posterior probabilities from 10 CV
colnames(pred_data) = c("pZgivenG","pZgivenGE")

# Set indexes of K-fold CV
idx_samples.out = which(basic_data[,"E_disc"]==1)
idx_samples.nonout = setdiff(1:nrow(basic_data),idx_samples.out)

idx_folds.out <- createFolds(idx_samples.out, k = Kfold, list = TRUE, returnTrain = FALSE)
idx_folds.nonout <- createFolds(idx_samples.nonout, k = Kfold, list = TRUE, returnTrain = FALSE)

for (k in 1:Kfold) {
  # Assign indexes of k-fold training and test data from the pool generated
  if (k==10){
    idx_out.test <- eval(parse(text = "idx_folds.out$Fold10"))
  } else {
    idx_out.test <- eval(parse(text = paste("idx_folds.out$Fold0",k,sep="")))
  }
  
  idx_out.trng = vector()
  for (i in setdiff(1:Kfold,k)){
    if (i==10){
      idx_out.trng = c(idx_out.trng,eval(parse(text = "idx_folds.out$Fold10")))
    } else {
      idx_out.trng = c(idx_out.trng,eval(parse(text = paste("idx_folds.out$Fold0",i,sep=""))))
    }
  }
  
  if (k==10){
    idx_nonout.test <- eval(parse(text = "idx_folds.nonout$Fold10"))
  } else {
    idx_nonout.test <- eval(parse(text = paste("idx_folds.nonout$Fold0",k,sep="")))
  }
  
  idx_nonout.trng = vector()
  for (i in setdiff(1:Kfold,k)){
    if (i==10){
      idx_nonout.trng = c(idx_nonout.trng,eval(parse(text = "idx_folds.nonout$Fold10")))
    } else {
      idx_nonout.trng = c(idx_nonout.trng,eval(parse(text = paste("idx_folds.nonout$Fold0",i,sep=""))))
    }
  }
  
  # Indexes of training and test data
  idx_trng = sample(c(idx_samples.out[idx_out.trng],idx_samples.nonout[idx_nonout.trng]))
  idx_test = sample(c(idx_samples.out[idx_out.test],idx_samples.nonout[idx_nonout.test]))
  
  # training & test data by holding out test data
  g_trng = as.matrix(basic_data[idx_trng,(which(colnames(basic_data)=="gene")+1):ncol(basic_data)])
  g_test = as.matrix(basic_data[idx_test,(which(colnames(basic_data)=="gene")+1):ncol(basic_data)])
  
  # Find a best lambda from a multivariate logistic regression with outlier statuses with 10 cross-validation
  costs = c(100, 10, 1, .1, .01, 1e-3, 1e-4) # a list of candidate lambdas for L2 penalty in multivariate logistic regression
  cv.ll = cv.glmnet(g_trng, as.vector(basic_data[idx_trng,"E_disc"]), lambda=costs, family="binomial", alpha = 0, nfolds=10); # genome annotation only model
  print(paste(" *** ",k,"-fold CV: Genomic annotation model, lambda = ",cv.ll$lambda.min," *** ",sep=""))
  
  # Compute a P(FR | G) for test data
  pred_data[idx_test,"pZgivenG"] = predict(cv.ll, g_test, s="lambda.min", type='response');
  
  # Train RIVER on training data
  theta = matrix(c(.99, .01, .3, .7), nrow=2, ncol=2) # initial theta
  em.res <- integratedEM(g_trng, as.vector(basic_data[idx_trng,"E_disc"]), cv.ll$lambda.min, pseudocount, theta, cv.ll$glmnet.fit, costs);
  print(paste(" *** ",k,"-fold CV: RIVER *** ",sep=""))
  
  # Compute P(FR | G, E)
  pred_data[idx_test,"pZgivenGE"] = testPosteriors(g_test, as.vector(basic_data[idx_test,"E_disc"]), em.res)$posterior[,2];  
}



# =========== Save data
save.image(file = paste(dir,"/data/RIVER.10CV.out.RData",sep=""))